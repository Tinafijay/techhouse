<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>UltraShare Pro v11 (Connection Fix)</title>
<meta name="theme-color" content="#2563eb">
<!-- Updated PeerJS with fallback -->
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>

<style>
/* [Keep all the same CSS styles - they're fine] */
</style>
</head>
<body>

<!-- [Keep all the same HTML structure - it's fine] -->

<div id="toast-box"></div>

<script>
/* ULTRA-SHARE PRO V11 - CONNECTION FIX */

// Force HTTPS
if (location.protocol !== 'https:' && location.hostname !== 'localhost' && !location.href.includes('127.0.0.1')) {
  location.replace(`https:${location.href.substring(location.protocol.length)}`);
}

const $ = id => document.getElementById(id);
const myCode = Math.floor(100000 + Math.random() * 900000).toString();
const PREFIX = 'us_v11_';
let peer = null;
let conn = null;
let fileQueue = [];
let isSending = false;
let connectionTimeout = null;

// Logging
function log(msg, type='') {
  const line = document.createElement('div');
  line.className = `log-line ${type}`;
  line.textContent = `> ${msg}`;
  const c = $('console');
  c.appendChild(line);
  c.scrollTop = c.scrollHeight;
  console.log(`[UltraShare] ${msg}`); // Also log to console for debugging
  if(type === 'error') toast(msg);
}

function toast(msg) {
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  $('toast-box').appendChild(t);
  setTimeout(()=>t.remove(), 3000);
}

function updateStatus(state, msg = '') {
  const d = $('statusDot');
  const t = $('statusText');
  
  if(state === 'online') { 
    d.className='dot green'; 
    t.textContent = msg || 'Connected'; 
    $('btnConnect').textContent='Connected'; 
    $('btnConnect').disabled=true; 
    $('destId').disabled=true; 
  }
  else if(state === 'connecting') { 
    d.className='dot orange'; 
    t.textContent = msg || 'Connecting...'; 
    $('btnConnect').textContent='Working...'; 
    $('btnConnect').disabled = true;
  }
  else if(state === 'error') {
    d.className='dot'; 
    t.textContent = msg || 'Error'; 
    $('btnConnect').textContent='Retry Connect';
    $('btnConnect').disabled = false;
    $('destId').disabled = false;
  }
  else { 
    d.className='dot'; 
    t.textContent = msg || 'Ready'; 
    $('btnConnect').textContent='Connect'; 
    $('btnConnect').disabled=false; 
    $('destId').disabled=false; 
  }
}

// 1. FIXED PEER INITIALIZATION WITH BETTER CONFIG
function initPeer() {
  log('Initializing PeerJS...');
  
  try {
    // Use multiple PeerJS servers for reliability
    const servers = [
      { host: '0.peerjs.com', port: 443, path: '/', secure: true },
      { host: '1.peerjs.com', port: 443, path: '/', secure: true },
      { host: '2.peerjs.com', port: 443, path: '/', secure: true }
    ];
    
    const server = servers[Math.floor(Math.random() * servers.length)];
    log(`Using server: ${server.host}`);
    
    peer = new Peer(PREFIX + myCode, {
      debug: 3, // Maximum debugging
      secure: true,
      host: server.host,
      port: server.port,
      path: server.path,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
          { urls: 'stun:stun3.l.google.com:19302' },
          { urls: 'stun:stun4.l.google.com:19302' },
          // TURN servers for difficult networks (public but may help)
          { 
            urls: 'turn:openrelay.metered.ca:80',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          { 
            urls: 'turn:openrelay.metered.ca:443',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ],
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all',
        rtcpMuxPolicy: 'require'
      },
      iceTransportPolicy: 'all'
    });

    peer.on('open', (id) => {
      $('myId').textContent = myCode;
      log(`âœ“ Your ID: ${myCode}`, 'success');
      log('Share this code with your partner');
      updateStatus('ready', 'Ready');
    });

    peer.on('error', (err) => {
      console.error('PeerJS Error:', err);
      
      // Specific error handling
      if(err.type === 'network') {
        log('Network error. Check your internet connection.', 'error');
      } else if(err.type === 'server-error') {
        log('Signaling server error. Trying alternative server...', 'error');
        setTimeout(initPeer, 1000);
      } else if(err.type === 'peer-unavailable') {
        log('Partner not found. Make sure they entered your code correctly.', 'error');
      } else if(err.type === 'disconnected') {
        log('Lost connection to signaling server. Reconnecting...', 'error');
        setTimeout(() => {
          if(peer && !peer.destroyed) {
            peer.reconnect();
          } else {
            initPeer();
          }
        }, 1000);
      } else {
        log(`Error: ${err.type} - ${err.message}`, 'error');
      }
      
      updateStatus('error', 'Error - Retry');
    });

    // CRITICAL FIX: Handle incoming connections properly
    peer.on('connection', (incomingConn) => {
      log(`Incoming connection detected from ${incomingConn.peer}`);
      
      // Close any existing connection
      if(conn && conn.open) {
        log('Closing existing connection for new one...');
        conn.close();
      }
      
      conn = incomingConn;
      setupConnectionHandlers(conn);
      
      // For incoming connections, they should be immediately open
      // but we need to verify
      if(conn.open) {
        onConnectionSuccess();
      } else {
        // Some connections need a moment
        setTimeout(() => {
          if(conn && conn.open) {
            onConnectionSuccess();
          } else {
            log('Incoming connection failed to open', 'error');
          }
        }, 500);
      }
    });

    peer.on('disconnected', () => {
      log('Disconnected from server. Reconnecting...', 'error');
      updateStatus('error', 'Reconnecting...');
      setTimeout(() => peer.reconnect(), 2000);
    });

    peer.on('close', () => {
      log('Peer closed. Reinitializing...', 'error');
      updateStatus('error', 'Restarting...');
      setTimeout(initPeer, 3000);
    });

  } catch (error) {
    log(`Failed to initialize: ${error.message}`, 'error');
    updateStatus('error', 'Init Failed');
    setTimeout(initPeer, 2000);
  }
}

// 2. SETUP CONNECTION HANDLERS
function setupConnectionHandlers(connection) {
  if(!connection) return;
  
  connection.on('open', () => {
    onConnectionSuccess();
  });
  
  connection.on('data', (data) => {
    processData(data);
  });
  
  connection.on('close', () => {
    log('Connection closed by partner', 'error');
    updateStatus('ready', 'Disconnected');
    conn = null;
  });
  
  connection.on('error', (err) => {
    log(`Connection error: ${err.message || err.type}`, 'error');
    updateStatus('error', 'Connection Failed');
  });
}

// 3. CONNECTION SUCCESS HANDLER
function onConnectionSuccess() {
  if(!conn || !conn.open) return;
  
  clearTimeout(connectionTimeout);
  log('âœ“ Connection established successfully!', 'success');
  log('You can now send files and chat');
  toast('Connected! Ready to share.');
  updateStatus('online', 'Connected');
  
  // Send handshake to confirm
  setTimeout(() => {
    sendData({ 
      type: 'handshake', 
      code: myCode,
      timestamp: Date.now(),
      message: 'Hello from UltraShare!' 
    });
  }, 100);
}

// 4. IMPROVED CONNECT FUNCTION
$('btnConnect').onclick = () => {
  const code = $('destId').value.trim().replace(/\D/g, '');
  
  if(code.length !== 6) {
    toast('Enter a 6-digit code');
    $('destId').focus();
    return;
  }
  
  if(code === myCode) {
    toast('Cannot connect to yourself');
    return;
  }
  
  if (!peer || peer.disconnected) {
    toast('Network not ready. Please wait...');
    return;
  }
  
  log(`Connecting to ${code}...`);
  updateStatus('connecting', `Connecting to ${code}...`);
  
  // Clear previous timeout
  if (connectionTimeout) clearTimeout(connectionTimeout);
  
  try {
    // Create connection with timeout
    const fullPeerId = PREFIX + code;
    log(`Attempting to connect to: ${fullPeerId}`);
    
    const c = peer.connect(fullPeerId, {
      reliable: true,
      serialization: 'json',
      metadata: { 
        version: 'v11', 
        myCode: myCode,
        timestamp: Date.now(),
        userAgent: navigator.userAgent 
      }
    });
    
    if (!c) {
      throw new Error('Failed to create connection');
    }
    
    conn = c;
    setupConnectionHandlers(conn);
    
    // Set connection timeout
    connectionTimeout = setTimeout(() => {
      if(conn && !conn.open) {
        log('Connection timeout after 25 seconds', 'error');
        log('Possible issues:', 'error');
        log('1. Partner might not be online', 'error');
        log('2. Check if both devices are on same network', 'error');
        log('3. Try refreshing both pages', 'error');
        
        if(conn) conn.close();
        updateStatus('error', 'Timeout');
        conn = null;
      }
    }, 25000);
    
  } catch (error) {
    clearTimeout(connectionTimeout);
    log(`Connection failed: ${error.message}`, 'error');
    updateStatus('error', 'Failed');
    conn = null;
  }
};

// 5. SEND DATA WITH VALIDATION
function sendData(data) {
  if(!conn || !conn.open) {
    log('Cannot send: No active connection', 'error');
    return false;
  }
  
  try {
    let dataToSend;
    
    if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
      dataToSend = data;
    } else {
      dataToSend = JSON.stringify(data);
    }
    
    conn.send(dataToSend);
    return true;
  } catch (error) {
    log(`Send failed: ${error.message}`, 'error');
    return false;
  }
}

// 6. PROCESS INCOMING DATA
function processData(rawData) {
  console.log('Received data:', typeof rawData, rawData);
  
  // Binary data (file chunks)
  if(rawData instanceof ArrayBuffer || rawData instanceof Uint8Array) {
    receiveChunk(rawData);
    return;
  }
  
  // String data (JSON)
  let data;
  try {
    if (typeof rawData === 'string') {
      data = JSON.parse(rawData);
    } else {
      data = rawData;
    }
  } catch (e) {
    log('Failed to parse data', 'error');
    return;
  }
  
  if (!data || !data.type) return;
  
  switch(data.type) {
    case 'handshake':
      log(`Partner connected: ${data.code || 'Unknown'}`, 'success');
      if(data.message) {
        log(`Message: ${data.message}`);
      }
      break;
      
    case 'chat':
      if(data.msg) {
        addChat(data.msg, false);
      }
      break;
      
    case 'file-meta':
      startReceiving(data);
      break;
      
    case 'file-chunk': 
      if (data.chunk) {
        receiveChunk(data.chunk);
      }
      break;
      
    default:
      log(`Unknown data type: ${data.type}`);
  }
}

// 7. FILE TRANSFER ENGINE (unchanged but with error handling)
const CHUNK_SIZE = 16 * 1024;

$('fileIn').onchange = (e) => {
  fileQueue = [...e.target.files];
  updateFileUI();
};

function updateFileUI() {
  const q = $('fileQueue');
  q.innerHTML = '';
  fileQueue.forEach(f => {
    const d = document.createElement('div');
    d.className = 'file-item';
    d.innerHTML = `<span>ðŸ“„ ${f.name}</span> <small>${(f.size/1024/1024).toFixed(1)} MB</small>`;
    q.appendChild(d);
  });
  $('btnSend').style.display = fileQueue.length ? 'block' : 'none';
}

$('btnSend').onclick = async () => {
  if(!conn || !conn.open) {
    toast('Not connected to partner!');
    switchTab('tab-connect');
    return;
  }
  
  if(isSending) return;
  
  isSending = true;
  $('btnSend').disabled = true;
  $('transferCard').style.display = 'block';
  $('progressBar').style.width = '0%';
  $('transferText').children[1].textContent = '0%';
  
  try {
    for(let file of fileQueue) {
      log(`Starting transfer: ${file.name}...`);
      
      // Send file metadata
      const metaSent = sendData({ 
        type: 'file-meta', 
        name: file.name, 
        size: file.size, 
        mime: file.type,
        id: Date.now() + Math.random()
      });
      
      if (!metaSent) {
        throw new Error('Failed to send file metadata');
      }
      
      await new Promise(r => setTimeout(r, 200));
      
      // Send file in chunks
      let offset = 0;
      const reader = new FileReader();
      
      while(offset < file.size) {
        const chunk = file.slice(offset, offset + CHUNK_SIZE);
        
        // Wait if buffer is too full
        if(conn.dataChannel && conn.dataChannel.bufferedAmount > 16000000) {
          await new Promise(r => setTimeout(r, 100));
        }
        
        const arrayBuffer = await new Promise((resolve) => {
          reader.onload = (e) => resolve(e.target.result);
          reader.readAsArrayBuffer(chunk);
        });
        
        conn.send(arrayBuffer);
        offset += arrayBuffer.byteLength;
        
        // Update progress
        const pct = Math.round((offset/file.size)*100);
        $('progressBar').style.width = pct + '%';
        $('transferText').children[1].textContent = pct + '%';
        
        // Small delay to prevent overwhelming
        if (offset % (CHUNK_SIZE * 5) === 0) {
          await new Promise(r => setTimeout(r, 10));
        }
      }
      
      log(`âœ“ Sent: ${file.name}`, 'success');
    }
    
    toast('All files sent successfully!');
    
  } catch (error) {
    log(`File transfer failed: ${error.message}`, 'error');
    toast('Transfer failed');
  } finally {
    isSending = false;
    fileQueue = [];
    updateFileUI();
    $('btnSend').disabled = false;
    $('transferCard').style.display = 'none';
  }
};

// 8. RECEIVING ENGINE
let incoming = null;
let rxChunks = [];
let rxBytes = 0;

function startReceiving(meta) {
  incoming = meta;
  rxChunks = [];
  rxBytes = 0;
  log(`Receiving: ${meta.name} (${(meta.size/1024/1024).toFixed(2)} MB)`, 'success');
  switchTab('tab-receive');
}

function receiveChunk(buff) {
  if(!incoming) return;
  rxChunks.push(buff);
  rxBytes += buff.byteLength || buff.length;
  
  if(rxBytes >= incoming.size) {
    const blob = new Blob(rxChunks, {type: incoming.mime});
    const url = URL.createObjectURL(blob);
    
    const item = document.createElement('div');
    item.className = 'file-item';
    item.style.justifyContent = 'space-between';
    item.innerHTML = `
      <div>
        <div style="font-weight:bold">${incoming.name}</div>
        <div style="font-size:12px; color:#64748b">${(incoming.size/1024/1024).toFixed(1)} MB â€¢ Received</div>
      </div>
      <a href="${url}" download="${incoming.name}" class="btn" style="width:auto; padding:8px 16px;">Download</a>
    `;
    $('receiveList').prepend(item);
    
    incoming = null;
    rxChunks = [];
    toast('File received!');
  }
}

// 9. CHAT FUNCTIONALITY
$('btnMsg').onclick = () => {
  const txt = $('msgInput').value.trim();
  if(!txt) return;
  
  if (sendData({ type: 'chat', msg: txt, sender: myCode, time: new Date().toLocaleTimeString() })) {
    addChat(txt, true);
    $('msgInput').value = '';
  }
};

$('msgInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    $('btnMsg').click();
  }
});

function addChat(txt, mine) {
  const b = document.createElement('div');
  b.className = `bubble ${mine?'mine':'theirs'}`;
  b.textContent = txt;
  $('msgList').appendChild(b);
  $('msgList').scrollTop = $('msgList').scrollHeight;
  if(!mine) switchTab('tab-chat');
}

// 10. TAB SWITCHING
function switchTab(id) {
  document.querySelectorAll('.main-view').forEach(e => e.classList.remove('active'));
  document.querySelectorAll('.nav-btn').forEach(e => e.classList.remove('active'));
  $(id).classList.add('active');
  const idx = ['tab-connect','tab-send','tab-chat','tab-receive'].indexOf(id);
  if(document.querySelectorAll('.nav-btn')[idx]) {
    document.querySelectorAll('.nav-btn')[idx].classList.add('active');
  }
}

// 11. DIAGNOSTICS
function runDiagnostics() {
  console.group('UltraShare Diagnostics');
  console.log('My Code:', myCode);
  console.log('Peer:', peer ? 'Initialized' : 'Not initialized');
  console.log('Connection:', conn ? (conn.open ? 'Open' : 'Closed') : 'None');
  console.log('User Agent:', navigator.userAgent);
  console.log('WebRTC Support:', 'RTCPeerConnection' in window);
  console.log('DataChannel Support:', 'RTCDataChannel' in window);
  console.groupEnd();
}

// INITIALIZE
document.addEventListener('DOMContentLoaded', () => {
  log('UltraShare Pro v11 starting...');
  log('Hosted on GitHub Pages');
  
  // Run diagnostics
  runDiagnostics();
  
  // Initialize after a short delay
  setTimeout(() => {
    initPeer();
    
    // Auto-refresh if stuck for too long
    setTimeout(() => {
      if(!peer || peer.disconnected) {
        log('Taking too long to initialize. Refreshing...', 'error');
        toast('Refreshing page...');
        setTimeout(() => location.reload(), 1000);
      }
    }, 10000);
  }, 500);
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if(document.visibilityState === 'visible') {
    if(peer && (peer.disconnected || !peer.open)) {
      log('Page became visible, reconnecting...');
      peer.reconnect();
    }
  }
});

// Handle beforeunload
window.addEventListener('beforeunload', () => {
  if(conn && conn.open) {
    conn.close();
  }
  if(peer && !peer.destroyed) {
    peer.destroy();
  }
});

</script>
</body>
</html>